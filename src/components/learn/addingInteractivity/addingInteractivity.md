コンポーネントに双方向性を加えていく方法について
双方向性：ユーザの入力に対して、システムが何らかの結果・反応を返すこと。一方通行ではなく、ユーザも何かを得られる。

interaction：
複数の存在が互いに影響を及ぼしあうこと。動作しているプログラムとそれを使用しているユーザとの間を結ぶ手段。

## Responding to Events
JSXには、クリックやホバー、フォーカスなどのような操作に反応して発火する関数イベントハンドラを追加することができる。
イベントには、onClickやonChangeなどがある。
イベントハンドラを追加するためには、コンポーネントの内部に関数を宣言し、処理を記述。その関数をJSXのタグにpropとして渡す。
イベントハンドラは、handleから始める。関数として切り出さずに、JSXの中で定義することもできる。
イベントには、関数を「渡す」だけ。呼び出さないようにする。呼び出してしまうと、操作をせずともレンダリング中に発火してしまう。

イベントに渡す関数自体をpropとし、コンポーネントに渡すことができる。これは、同じコンポーネントをいくつかの場所に配置して、それぞれ異なる関数を実行することを可能にする。
コンポーネントにpropとしてイベントハンドラを渡す場合、onClickなど決められたイベントを使わずに、処理やアプリの特徴に合わせて名付けることも可能。

イベントハンドラは、そのコンポーネントにあるどの子要素のイベントにも反応して発火することができてしまう。イベントハンドラを持つ要素の子要素にもイベントハンドラを用意してしまうと、子要素のイベントハンドラが発火したのち、その親要素のイベントハンドラにも伝わって発火してしまう。onScrollを除いて、すべてのイベントは伝播してしまう性質。
ただし、伝播してしまわないようにすることも可能。イベントハンドラは引数として、イベントの情報を取得できるeventオブジェクトを受け取ることができる。親コンポーネントまでイベントが伝播するのを防ぐためには、子コンポーネントでイベントオブジェクトが持つstopPropagationメソッドを呼び出す。
イベントの伝播の代わりに、親コンポーネントのイベントハンドラを呼び出す前に処理を追加することもできる。これは、イベントの結果として実行されたイベントハンドラの一連のコード全体を追いやすくなるというメリットがある。
イベントの伝播に頼ってしまうと、どのイベントハンドラが実行されたのか、なぜ実行されたのかがわかりにくくなる。

いくつかのイベントは関連づけられたデフォルトの動作を持っており、何も指定していないと実行できてしまう。formタグのsubmitイベントの場合だと、formタグ内のbuttonタグに何もイベントハンドラを指定していなくても、デフォルトの動作によってページ全体をリロードする。これらのデフォルトの動作を発生させないようにするためには、eventオブジェクトのpreventDefaultメソッドを呼び出す。
stopPropagationメソッドとpreventDefaultメソッド、似ているが、役割は異なるため注意する。stopPropagationメソッドは、親コンポーネントへのイベントの伝播を防ぐ。preventDefaultメソッドは、イベントのデフォルト動作を実行させないようにする。

イベントハンドラは、純粋関数である必要はなく、副作用を持つのに最適である。例えば、タイピングに反応してインプットの値を変えたり、ボタン押下に反応してリストを変えるなど。ただ、何かの情報を変えるためには、まず情報を保存する必要がある。コンポーネントの記憶である、stateによって情報を記憶・保存できる。

※イベント：onClickやonChangeのような組み込まれたブラウザイベント。
イベントハンドラ：ユーザの操作によって実行される処理。

## State: A Component's Memory
反応に応じて、コンポーネントを変更する必要がある。コンポーネントは、現在の入力値や現在の画像、現在のショッピングカートの状態を記憶する必要がある。このコンポーネント特有の記憶をstateと呼ぶ。

イベントハンドラでローカル変数を更新しても、その変化が表示に反映されない。これには2つの原因がある。
- Reactは、再度レンダリングすると、ローカル変数の変化は無視して最初からレンダリングし直す。
- ローカル変数の変更は、再レンダリングを促さない。新しいデータでコンポーネントを再度レンダリングする必要があることに気が付かない。

コンポーネントを新しいデータで更新するためには、
- レンダリング間でデータを保持すること
- 新しいデータでコンポーネントを再レンダリングすることを促すこと
が必要。useStateフックはこれらを実現できる。
- state変数はレンダリング間でデータを保持できる。
- stateセッター関数は変数の更新とReactにコンポーネントの再レンダリングを促すことができる。

フックとは、useから始まる関数。特別な関数で、Reactがレンダリングしている間のみ有効な関数。

useStateを呼ぶと、そのコンポーネントにstate変数を記憶して欲しいことがReactに伝わる。
useStateの引数は、初期値のみ。コンポーネントがレンダリングされるたびに、useStateは、値が保管されているstate変数とstate変更を更新してコンポーネントの再レンダリングを促すstateセッター関数を要素とする配列を返す。分割代入ににている。

stateはコンポーネントのインスタンスのローカルのデータであり、同じコンポーネントでstate変更・レンダリング実行しても、他の同じコンポーネントは影響を受けない。コンポーネントごとにstateは別々に保管されている。

## Render and Commit
コンポーネントが、具材から美味しい料理へと組み合わせていくように、キッチンで調理査定る状況を想像してください。この状況では、Reactは、お客さんからオーダーを聞いてキッチンにいる料理人に伝え、できた料理をお客さんの席に届ける、ウェイターの役割をする。

- Trigger：オーダーをキッチンに伝える→レンダリングを促す

- Rendering：キッチンで調理→コンポーネントをレンダリングする

- Commit：料理を席に届ける→DOMに渡す・組み入れる

### Step 1: Trigger a render
Trigger。
コンポーネントがレンダリングするのは2つの理由がある。
- コンポーネントの初回レンダリングである。
createRootを対象のDOMノードと一緒に呼び出し、そのrenderメソッドをコンポーネントと一緒に呼び出す。
renderメソッドをコメントアウトしてみると、何も表示されなくなる。

- コンポーネントまたはその子孫のstateが更新された。
初回レンダリング以降は、set関数のstate更新によってレンダリングを促すことができる。コンポーネントのstateを更新すると自動的にレンダリング待ちになる。次々と料理が注文されていくイメージ。キュー。

### Step 2: React renders your components
Rendering。
レンダリングを促したら、Reactは画面に何を表示するのかを知るためにコンポーネントを呼び出す。「レンダリング」とは、Reactがコンポーネントを呼び出して何を表示するか知ること。表示することではない。

- 初回レンダリングでは、rootコンポーネントを呼び出す。
DOMを構成する、HTML要素を生成する。

- それ以降のレンダリングでは、レンダリングを促したstateが更新されたコンポーネントを呼び出す。
前回のレンダリングから変化があるかプロパティを計算する。そこでコンポーネントの情報を知るが、まだ何もしない。

この処理は再帰的である。もしstateが更新されたコンポーネントがほかのコンポーネントを返していたら、そのコンポーネントを次にレンダリング(呼び出し)し、そのコンポーネントもまた別のコンポーネントを返していたら、また次にそのコンポーネントをレンダリングする...といったように、ネストされているコンポーネントがなくなり、Reactが画面に表示するべきものを正確に知るまで、この呼び出しは続く。

レンダリングは、同じ入力であれば、同じ結果を返す純粋関数でなければならない。オブジェクトや変数を変えてはいけない。

### Step 3: React commits changes to the DOM
Commit。
コンポーネントを呼び出した後は、ReactはDOMを修正する。

- 初回レンダリングでは、appendChildを使って、画面に生成されたDOMノードを全て入れる。

- 再レンダリングでは、DOMを最新のレンダリングの計算結果に合わせるために必要最低限の動作をする。

レンダリングとDOMに違いがあれば、ReactはDOMを変更する。

### Epilogue: Browser paint
レンダリングが完了し、DOMを更新したら、ブラウザは画面を描き直す。この処理は、ブラウザレンダリングを呼ばれる。Reactのレンダリングとは異なり、画面に表示していく。

## State as a Snapshot
state変数は、読み込みと書き込み(再代入)ができる普通のJavaScript変数のように見えるかもしれない。しかし、stateは、スナップショットのように振舞う。スナップショットとは、ある時点での状態を抜き出したもの。stateをセットすることは、stateを変更すること(stateに再代入すること)ではなく、再レンダリングを促すことだ。

Renderingとは、コンポーネント関数を呼び出すこと。その間に、コンポーネント関数からUIのスナップショットのようにJSXが返される。
コンポーネントの記憶としてのstateは、関数から返されたら消えてしまう普通の変数とは異なり、Reactの中で生き続ける。Reactがコンポーネントを呼び出すと、特定のレンダリングのためにstateのスナップショットを提供する。コンポーネントはstateの値を使って計算されたJSXの中の新しいpropsやイベントハンドラとともに、UIのスナップショットを返す。

イベントハンドラの中では、Reactは変更されたstateの値を保持する。そのため、コードが実行されている間にstateが更新されたかどうかを気にする必要はない。
ただ、再レンダリングの前に、最新のstateを読み込みたい場合には、state更新関数を使う。