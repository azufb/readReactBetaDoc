コンポーネントに双方向性を加えていく方法について
双方向性：ユーザの入力に対して、システムが何らかの結果・反応を返すこと。一方通行ではなく、ユーザも何かを得られる。

interaction：
複数の存在が互いに影響を及ぼしあうこと。動作しているプログラムとそれを使用しているユーザとの間を結ぶ手段。

## Responding to Events
JSXには、クリックやホバー、フォーカスなどのような操作に反応して発火する関数イベントハンドラを追加することができる。
イベントには、onClickやonChangeなどがある。
イベントハンドラを追加するためには、コンポーネントの内部に関数を宣言し、処理を記述。その関数をJSXのタグにpropとして渡す。
イベントハンドラは、handleから始める。関数として切り出さずに、JSXの中で定義することもできる。
イベントには、関数を「渡す」だけ。呼び出さないようにする。呼び出してしまうと、操作をせずともレンダリング中に発火してしまう。

イベントに渡す関数自体をpropとし、コンポーネントに渡すことができる。これは、同じコンポーネントをいくつかの場所に配置して、それぞれ異なる関数を実行することを可能にする。
コンポーネントにpropとしてイベントハンドラを渡す場合、onClickなど決められたイベントを使わずに、処理やアプリの特徴に合わせて名付けることも可能。

イベントハンドラは、そのコンポーネントにあるどの子要素のイベントにも反応して発火することができてしまう。イベントハンドラを持つ要素の子要素にもイベントハンドラを用意してしまうと、子要素のイベントハンドラが発火したのち、その親要素のイベントハンドラにも伝わって発火してしまう。onScrollを除いて、すべてのイベントは伝播してしまう性質。
ただし、伝播してしまわないようにすることも可能。イベントハンドラは引数として、イベントの情報を取得できるeventオブジェクトを受け取ることができる。親コンポーネントまでイベントが伝播するのを防ぐためには、子コンポーネントでイベントオブジェクトが持つstopPropagationメソッドを呼び出す。
イベントの伝播の代わりに、親コンポーネントのイベントハンドラを呼び出す前に処理を追加することもできる。これは、イベントの結果として実行されたイベントハンドラの一連のコード全体を追いやすくなるというメリットがある。
イベントの伝播に頼ってしまうと、どのイベントハンドラが実行されたのか、なぜ実行されたのかがわかりにくくなる。

いくつかのイベントは関連づけられたデフォルトの動作を持っており、何も指定していないと実行できてしまう。formタグのsubmitイベントの場合だと、formタグ内のbuttonタグに何もイベントハンドラを指定していなくても、デフォルトの動作によってページ全体をリロードする。これらのデフォルトの動作を発生させないようにするためには、eventオブジェクトのpreventDefaultメソッドを呼び出す。
stopPropagationメソッドとpreventDefaultメソッド、似ているが、役割は異なるため注意する。stopPropagationメソッドは、親コンポーネントへのイベントの伝播を防ぐ。preventDefaultメソッドは、イベントのデフォルト動作を実行させないようにする。

イベントハンドラは、純粋関数である必要はなく、副作用を持つのに最適である。例えば、タイピングに反応してインプットの値を変えたり、ボタン押下に反応してリストを変えるなど。ただ、何かの情報を変えるためには、まず情報を保存する必要がある。コンポーネントの記憶である、stateによって情報を記憶・保存できる。

※イベント：onClickやonChangeのような組み込まれたブラウザイベント。
イベントハンドラ：ユーザの操作によって実行される処理。

## State: A Component's Memory
反応に応じて、コンポーネントを変更する必要がある。コンポーネントは、現在の入力値や現在の画像、現在のショッピングカートの状態を記憶する必要がある。このコンポーネント特有の記憶をstateと呼ぶ。

イベントハンドラでローカル変数を更新しても、その変化が表示に反映されない。これには2つの原因がある。
- Reactは、再度レンダリングすると、ローカル変数の変化は無視して最初からレンダリングし直す。
- ローカル変数の変更は、再レンダリングを促さない。新しいデータでコンポーネントを再度レンダリングする必要があることに気が付かない。

コンポーネントを新しいデータで更新するためには、
- レンダリング間でデータを保持すること
- 新しいデータでコンポーネントを再レンダリングすることを促すこと
が必要。useStateフックはこれらを実現できる。
- state変数はレンダリング間でデータを保持できる。
- stateセッター関数は変数の更新とReactにコンポーネントの再レンダリングを促すことができる。

フックとは、useから始まる関数。特別な関数で、Reactがレンダリングしている間のみ有効な関数。

useStateを呼ぶと、そのコンポーネントにstate変数を記憶して欲しいことがReactに伝わる。
useStateの引数は、初期値のみ。コンポーネントがレンダリングされるたびに、useStateは、値が保管されているstate変数とstate変更を更新してコンポーネントの再レンダリングを促すstateセッター関数を要素とする配列を返す。分割代入ににている。

stateはコンポーネントのインスタンスのローカルのデータであり、同じコンポーネントでstate変更・レンダリング実行しても、他の同じコンポーネントは影響を受けない。コンポーネントごとにstateは別々に保管されている。

## Render and Commit
コンポーネントが、具材から美味しい料理へと組み合わせていくように、キッチンで調理査定る状況を想像してください。この状況では、Reactは、お客さんからオーダーを聞いてキッチンにいる料理人に伝え、できた料理をお客さんの席に届ける、ウェイターの役割をする。

- Trigger：オーダーをキッチンに伝える→レンダリングを促す

- Rendering：キッチンで調理→コンポーネントをレンダリングする

- Commit：料理を席に届ける→DOMに渡す・組み入れる

### Step 1: Trigger a render
Trigger。
コンポーネントがレンダリングするのは2つの理由がある。
- コンポーネントの初回レンダリングである。
createRootを対象のDOMノードと一緒に呼び出し、そのrenderメソッドをコンポーネントと一緒に呼び出す。
renderメソッドをコメントアウトしてみると、何も表示されなくなる。

- コンポーネントまたはその子孫のstateが更新された。
初回レンダリング以降は、set関数のstate更新によってレンダリングを促すことができる。コンポーネントのstateを更新すると自動的にレンダリング待ちになる。次々と料理が注文されていくイメージ。キュー。

### Step 2: React renders your components
Rendering。
レンダリングを促したら、Reactは画面に何を表示するのかを知るためにコンポーネントを呼び出す。「レンダリング」とは、Reactがコンポーネントを呼び出して何を表示するか知ること。表示することではない。

- 初回レンダリングでは、rootコンポーネントを呼び出す。
DOMを構成する、HTML要素を生成する。

- それ以降のレンダリングでは、レンダリングを促したstateが更新されたコンポーネントを呼び出す。
前回のレンダリングから変化があるかプロパティを計算する。そこでコンポーネントの情報を知るが、まだ何もしない。

この処理は再帰的である。もしstateが更新されたコンポーネントがほかのコンポーネントを返していたら、そのコンポーネントを次にレンダリング(呼び出し)し、そのコンポーネントもまた別のコンポーネントを返していたら、また次にそのコンポーネントをレンダリングする...といったように、ネストされているコンポーネントがなくなり、Reactが画面に表示するべきものを正確に知るまで、この呼び出しは続く。

レンダリングは、同じ入力であれば、同じ結果を返す純粋関数でなければならない。オブジェクトや変数を変えてはいけない。

### Step 3: React commits changes to the DOM
Commit。
コンポーネントを呼び出した後は、ReactはDOMを修正する。

- 初回レンダリングでは、appendChildを使って、画面に生成されたDOMノードを全て入れる。

- 再レンダリングでは、DOMを最新のレンダリングの計算結果に合わせるために必要最低限の動作をする。

レンダリングとDOMに違いがあれば、ReactはDOMを変更する。

### Epilogue: Browser paint
レンダリングが完了し、DOMを更新したら、ブラウザは画面を描き直す。この処理は、ブラウザレンダリングを呼ばれる。Reactのレンダリングとは異なり、画面に表示していく。

## State as a Snapshot
state変数は、読み込みと書き込み(再代入)ができる普通のJavaScript変数のように見えるかもしれない。しかし、stateは、スナップショットのように振舞う。スナップショットとは、ある時点での状態を抜き出したもの。stateをセットすることは、stateを変更すること(stateに再代入すること)ではなく、再レンダリングを促すことだ。

Renderingとは、コンポーネント関数を呼び出すこと。その間に、コンポーネント関数からUIのスナップショットのようにJSXが返される。
コンポーネントの記憶としてのstateは、関数から返されたら消えてしまう普通の変数とは異なり、Reactの中で生き続ける。Reactがコンポーネントを呼び出すと、特定のレンダリングのためにstateのスナップショットを提供する。コンポーネントはstateの値を使って計算されたJSXの中の新しいpropsやイベントハンドラとともに、UIのスナップショットを返す。

イベントハンドラの中では、Reactは変更されたstateの値を保持する。そのため、コードが実行されている間にstateが更新されたかどうかを気にする必要はない。
ただ、再レンダリングの前に、最新のstateを読み込みたい場合には、state更新関数を使う。

## Queueing a Series of State Updates
state変数にセットすることは、レンダリング待ちの列を作ることになる。ただ、次のレンダリングまでに値に対していくつか操作したいこともあるだろう。これを行うためには、Reactのstate更新のバッチがどうなっているのか理解することが役にたつだろう。

Reactはstate更新を行う前に実行されたイベントハンドラ内の全てのコードが終わるのを待っている。これがイベントハンドラ内の複数の同一set関数の後で再レンダリングされる理由だ。イベントハンドラが終わるまでUIも更新されることはない。これは、Reactアプリケーションをより速く動かすバッチ処理だと知られている。

通常の使い方ではないが、再レンダリング前に同じstate変数を複数回更新したい場合には、次のstateの値ではなく、setNumber(n => n + 1)のような再レンダリング待ちのキューにある直前の値をもとに次の値を計算する関数を渡す。Reactに、値の置き換えではなく、「stateの値を使って何かをしてほしい」ことを伝える方法だ。

## Updating Objects in State
stateには、JavaScriptのどんな値でも入れられる。しかし、stateとして持つオブジェクトを直接変更してはならず、代わりに、新しいオブジェクトもしくは既存のオブジェクトのコピーを作ってstateにセットして使う必要がある。

### What’s a mutation?
stateには、JavaScriptのどんな値でも入れられる。数値や文字列、真偽値など。
これらの値は、「イミュータブル」である。「イミュータブル」とは、変更できない読み取り専用であるということ。値を置き換えるために再レンダリングを促すことができる。たとえば、stateの値が0から5に変わっても、その0自体は変わらない。組み込みのプリミティブ値を変更することはできない。

正確には、オブジェクト自身の中身を変更することは可能である。これは「ミューテーション」と呼ばれる。
しかし、オブジェクトはReactのstateの中で正確にはミュータブルだが、数値や真偽値、文字列と同じようにイミュータブルであるかのように扱う必要がある。オブジェクトを変化させる代わりに、オブジェクトを置き換える必要がある。

stateに入れられたどんなJavaScriptのオブジェクトでもデータでも、読み取り専用として扱わないといけない。

stateのset関数を使わないと、Reactはオブジェクトが変化したかどうか分からないから、何もしない。これは、食べ終わった料理のオーダーを変更しようとするようなものだ。(=何もできない。何もしない。)set関数を使わずに動くケースも存在するにはするが、おすすめしない。
また、オブジェクトの一部のプロパティを変更したい場合、変更しないプロパティはスプレッド構文を使うと毎回コピーせずに済む。

ネストしているオブジェクトの場合はどうだろうか。
その場合も、スプレッド構文を利用することができる。プロパティの値のオブジェクトの中で変更したいプロパティ以外はスプレッド構文で持ってきて、親のオブジェクトのプロパティをスプレッド構文で持ってくる。

## Updating Arrays in State
配列も、オブジェクトと同じく、変更できるデータだけど、stateの中では変更しないイミュータブルな値として扱わないといけない。
stateの値としてのオブジェクトや配列そのものを変化させても、再レンダリングが促されないためだ。変わるのは、1つ前のレンダリングで使われたstateだけ。(もうレンダリングが終わって画面に表示されているから、新しい値で再レンダリングされない限り画面の表示は変わらない。)

配列の中身を再代入(インデックス番号を指定して再代入)をしたり、配列自体に変更を加えるメソッドを使ってはならない。配列のstate変数を更新したい場合、filterメソッドやmapメソッドを使って新しい配列をset関数に渡す。

配列に追加する場合は、pushメソッドではなく、例えばスプレッド構文を利用する。動作としては変わらないが、pushメソッドは配列自体に変更を加えているが、スプレッド構文を使うことで、新しい配列を作って渡している。

配列から削除する場合は、spliceメソッドではなく、filterメソッドを使う。filterメソッドを使うことで、コールバック関数に配列の要素が渡され、条件に合った(true)の要素のみで構成された新たな配列が作られる。

配列の中身を変化させたい場合には、mapメソッドを使う。mapメソッドは、コールバック関数に渡された配列の各要素に対して処理を加え、新たな配列を作りだす。配列の中身を入れ替えるなどできる。

また、配列自体に変更を加えないスプレッド構文やmapメソッド、filterメソッドでは対応できないような場合もある。例えば、入れ替えやソートなど。reverseメソッドやsortメソッドを使うと、配列自体に変更を加えてしまうので、直接使うことはできない。
しかし。先に配列をコピーしてからであれば、そのコピーした配列を変化させることは問題ない。

配列の中にオブジェクトが入っている場合、配列をコピーしただけで中身のオブジェクトのプロパティを変更すると、元の配列のオブジェクトも変わってしまう。これを防ぐためには、スプレッド構文とmapメソッドを使うことができる。