# Escape Hatches

コンポーネントは、React の外のシステムをコントロールしたり、同期したりする必要があるかもしれない。たとえば、ブラウザ API を利用して input 要素にフォーカスを当てたり、React を使わずに実装されたビデオプレイヤーを止めたり、リモートサーバと接続したり、リモートサーバからメッセージを受け取ったりするなどがある。この章では、React から外に出て外部システムと接続できる避難口について学ぶ。
多くのアプリケーションロジックやデータフローは、これらに依存するべきではない。

## Referencing Values with Refs

コンポーネントにいくつかの情報を持っておいて欲しいけれども、レンダリングを促したくない場合、ref を使うことができる。
useRef フックを使って、コンポーネントに ref を追加することができる。コンポーネントの中で、useRef フックを呼び出し、初期値を引数として渡す。
userRef は、`{current: 値}`のようなオブジェクトを返す。現在の値は、current プロパティを通してアクセスすることができる。この値は、変更可能な値で、読み取り・書き込みの両方が可能。これは、React が追跡しない秘密のポケットのようなものだ。
ref は、state と同じように、数値だけでなく、文字列やオブジェクト、関数などを示すことができる。しかし、state とは異なり、ref は、current プロパティを持つ読み書き可能な純粋な JavaScript のオブジェクトである。

レンダリングに使われる情報は state として持ち、イベントハンドラのみで必要になって変更しても再レンダリングしない情報には ref を使うのが効率的である。

setter 関数を使わなくても値を変更できる ref は、state に比べて非厳格的だと思うかもしれない。だが、ref は頻繁には使われない非常口であり、大抵の場合は state を使う。
state は再レンダリングを促すため、表示される値も更新されるが、ref の場合は、再レンダリングを促さないため、表示される値は変わらない。ref は、レンダリング中は値を読み取ったり書き込んだりすることはできない。state はいつでも state の値を読み取ることができる。

ref はどういう場面で使うのか？たとえば、`setTimeout`の ID を保存したり、DOM 要素の操作・保存、計算が不要なそのほかのオブジェクトを保存するなどの場面が考えられる。コンポーネントがレンダリングロジックに影響を与えないような値をいくつか持つ必要がある場合、ref を選択する。

ref は外部システムやブラウザ API と一緒に使う場合に有用だが、多くのロジックやデータフローを ref に頼っている場合は、見直しが必要。ref は非常口として扱う。レンダリング中に ref の current プロパティの値の読み取り・書き込みを行わない。

「レンダリングごとに state はスナップショットのように振る舞い、state は同期的に更新されない」のような、state の制限は、ref には当てはまらない。current プロパティの値の変更はすぐに実行される。これは、ref 自身が単なる JavaScript のオブジェクトだからである。

## Manipulating the DOM with Refs

React はレンダリング結果に合わせて自動的に DOM を更新するので、コンポーネントはたいてい DOM を操作する必要はない。しかし、例えば、node にフォーカスを当てたり、スクロールしたり、大きさや位置を計算するなど、React が管理している DOM 要素に時々アクセスする必要がある。React にはそれらを実行する方法は組み込まれていないので、ref が使われる。

ref は、子コンポーネントには効かない。子コンポーネントで利用するためには、forwardRef を使って、子コンポーネントが渡された ref を実行する意思表示をする必要がある。
