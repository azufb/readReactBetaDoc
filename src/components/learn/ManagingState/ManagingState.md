## Reacting to Input with State
ReactはUIを操作するのに、宣言的な方法をとる。それそれのUIを操作するのではなく、コンポーネントに異なるstateを渡し、ユーザ入力に対する反応としてUIを切り替える。デザイナーがUIについて考える方法に似ている。

UIの反応を考えるとき、例えば、「フォームに入力されたら、submitボタンを有効にする」や「submitボタンを押した時、ボタンを無効にしてローディング表示にする」など考える。命令型プログラミングでは、これらはどのように反応するか直接対応している。起こったことによってUIを操作するための正確な方法を記述する必要がある。
別の状況を考えてみよう。車の助手席に座って、運転する人に道順を伝え案内する状況を想像する。運転する人はどこに行くのか知らないので、助手席にいるあなたの指示に従うだけ。もし、あなたが間違った道を伝えると、違う場所に着いてしまう。これは、命令的と呼ぶ。

命令的なUI操作は独立した例では十分だが、より複雑なシステムでは、管理が難しくなる。
Reactはこの問題を解決する。
Reactは、UIを直接操作することはない。これは、コンポーネントを直接、有効/無効や表示/非表示にすることはないということだ。その代わり、何を見せるかを宣言する。例えば、タクシーに乗って、運転手さんにどこに行きたいか伝えるような感じで。

宣言的にUIを構築する方法について
### Step 1: コンポーネントの表示状態の違いを識別する
まず、ユーザが見るであろうUIの状態の違いを視覚化する。例えば、「フォームが空の場合、submitボタンは無効にしておく」や「フォームの送信が成功したら、Thank youメッセージを表示して、フォームは消す」など、ロジックを追加する前にデザイナーがそれぞれの状態に合わせてモック・ガワを作成するように。

### Step 2: state変更のトリガーを決める
state更新は、次の2つの入力に応じて促すことができる。
- 人間による入力：ボタンクリック・フィールドへの入力・リンク遷移など
- コンピュータによる入力：ネットワークレスポンスが届いた・タイムアウト・画像読み込みなど。

上記どちらにおいても、UIを更新するためにはstate変数に値をセットする必要がある。フォームの開発においても、異なる入力に応じてstateを変更する必要がある。例えば、「文字が入力されたら、空のstateから文字が入力されたstateもしくは、テキストボックスが空であるか入力されているかを切り替える」や「submitが成功してネットワークレスポンスが成功して返ってきたら、stateをSuccessに切り替える」など。

### Step 3: useStateを使ってstateを表す
次に、useStateを使って、コンポーネントのstateを表す必要がある。

### Step 4: 不要なstate変数は削除する
表示したくないstateを表示してしまうことを防ぐため、リファクタリングを行い、不要なstate変数は削除してしまう。
「同じ情報を持つstateがほかに存在しないか」や「同じ情報が別のstate変数から求められないか」などを基準に、不要であれば削除していく。

### Step 5: stateに値をセットするために、イベントハンドラと繋げる

宣言型プログラミングは、命令的にUIを細かく管理するのではなく、UIの表示状態を説明する。
コンポーネントを開発するときには、「全ての表示状態を識別」「stateを変更するトリガーとなる、人間・コンピュータによる入力を決める」「useStateを使ってstateを表す」「不要なstate変数はバグ防止のために削除する」「イベントハンドラと繋げる」といった作業が必要になる。

## Choosing the State Structure
### state構成の原理
stateを持つコンポーネントを作るとき、いくつstate変数を使うかやstate変数の型はどうするかを選択する必要がある。よりよい選択をするための次のような原理を持つ準最適なstate構成があれば、正しくプログラムを書くことができる。

- いつも2つ以上のstate変数を一度に更新する場合、それらをまとめて1つのstate変数にすることを考える。
- state同士が矛盾しないようにする。
- 冗長にならないようにする。コンポーネントのpropsや既存のstate変数を使って計算して求めることができる情報は、stateにしない。また、親コンポーネントから渡ってきたpropsの値をstate変数に入れない。stateが初期化されるのは、最初のレンダリングだけなので、親コンポーネントから渡されるpropsの値が変化しても、stateが更新されなくなってしまう。入れるならconst変数に。
- 複数のstate変数やネストされたオブジェクトにおいて、同じデータをそれぞれで持たないようにする。
- 深くネストしたstateは更新が大変なので、できるだけネストせずフラットな状態にする。

## Sharing State Between Components
2つのコンポーネントにあるstateを毎回一緒に更新したいときがあるかもしれない。この場合は、それぞれのコンポーネントからそのstateは除き、それぞれのコンポーネントの共通の親コンポーネントにそのstateを持たせて、propとして渡す。これは、stateの「リフトアップ」と呼ばれる。

## Preserving and Resetting State
stateはコンポーネント間で独立しており、Reactは、UIツリーの中を基準にどのstateがどのコンポーネントに属しているのか追跡する。stateがいつ保存され、再レンダリング間でいつリセットするかコントロールすることができる。

ブラウザはUIを形作るために多くの木構造を利用する。Reactも同じく、作ったUIを形作るため、管理するために木構造を使う。Reactの場合は、JSXからUI木構造を作る。

コンポーネントにstateを与えた時、stateはコンポーネントの中で生きているように思うかもしれない。しかし、実際には、stateはReactの中にある。UI木構造の中でコンポーネントがどこにあるかによって、Reactはそれぞれのstateを正しいコンポーネントと結びつける。
Reactは、同じコンポーネントを同じ位置でレンダリングしている限り、stateを保ち続ける。

2つの同じコンポーネントを同じ場所でレンダリングする場合、stateが引き継がれてしまう。(コンポーネントは同じで、propsが異なる場合。)その場合、stateを分ける(リセットする)ためには、2つの方法がある。
- コンポーネントを別々の場所でレンダリングする。

- それぞれのコンポーネントにkeyを与える。
keyは、Reactがコンポーネントを区別するのに使うことができる。keyを特定することで、親コンポーネントの中での順番を伝える代わりに、Reactにkey自体が位置の一部のように使うことを伝える。このことから、Reactの目線ではJSXの中で同じ場所にレンダリングされるコンポーネントであっても、それらは異なるコンポーネントになる。

Reactは、同じコンポーネントを同じ位置でレンダリングする限り、stateを保ち続ける。stateは、JSXタグの中で保管されているのではなく、UI木構造と関連づけられている。コンポーネント定義をネストさせない。